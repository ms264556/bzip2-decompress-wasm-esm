// bzip2-wasm-es.js
async function Bzip2Module(moduleArg = {}) {
  var moduleRtn;
  var Module = moduleArg;
  var ENVIRONMENT_IS_WEB = true;
  var ENVIRONMENT_IS_WORKER = false;
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var _scriptName = import.meta.url;
  var scriptDirectory = "";
  var readAsync, readBinary;
  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    try {
      scriptDirectory = new URL(".", _scriptName).href;
    } catch {
    }
    {
      readAsync = async (url) => {
        var response = await fetch(url, { credentials: "same-origin" });
        if (response.ok) {
          return response.arrayBuffer();
        }
        throw new Error(response.status + " : " + response.url);
      };
    }
  } else {
  }
  var out = console.log.bind(console);
  var err = console.error.bind(console);
  var wasmBinary;
  var ABORT = false;
  var EXITSTATUS;
  var readyPromiseResolve, readyPromiseReject;
  var wasmMemory;
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  var HEAP64, HEAPU64;
  var runtimeInitialized = false;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    HEAP8 = new Int8Array(b);
    HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    HEAPU16 = new Uint16Array(b);
    HEAP32 = new Int32Array(b);
    HEAPU32 = new Uint32Array(b);
    HEAPF32 = new Float32Array(b);
    HEAPF64 = new Float64Array(b);
    HEAP64 = new BigInt64Array(b);
    HEAPU64 = new BigUint64Array(b);
  }
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(onPreRuns);
  }
  function initRuntime() {
    runtimeInitialized = true;
    wasmExports["u"]();
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(onPostRuns);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    readyPromiseReject?.(e);
    throw e;
  }
  var wasmBinaryFile;
  function findWasmBinary() {
    return base64Decode("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CxAgAAsLswIBBH8jAEEQayIFJAAgBSACNgIMIwBB0AFrIgMkACADIAI2AswBIANBoAFqIgJBAEEo/AsAIAMgAygCzAE2AsgBAkBBACABIANByAFqIANB0ABqIAIQLkEASA0AIAAoAkxBAEggACAAKAIAIgZBX3E2AgACfwJAAkAgACgCMEUEQCAAQdAANgIwIABBADYCHCAAQgA3AxAgACgCLCEEIAAgAzYCLAwBCyAAKAIQDQELQX8gABAiDQEaCyAAIAEgA0HIAWogA0HQAGogA0GgAWoQLgshASAEBH8gAEEAQQAgACgCJBEBABogAEEANgIwIAAgBDYCLCAAQQA2AhwgACgCFBogAEIANwMQQQAFIAELGiAAIAAoAgAgBkEgcXI2AgANAAsgA0HQAWokACAFQRBqJAALDwAgASAAKAIAaiACNgIACw0AIAEgACgCAGooAgALBQAQKgALwgEBA38CQCACKAIQIgMEfyADBSACECINASACKAIQCyACKAIUIgRrIAFJBEAgAiAAIAEgAigCJBEBAA8LAkACQCACKAJQQQBIDQAgAUUNACABIQMDQCAAIANqIgVBAWstAABBCkcEQCADQQFrIgMNAQwCCwsgAiAAIAMgAigCJBEBACIEIANJDQIgASADayEBIAIoAhQhBAwBCyAAIQVBACEDCyAEIAUgARAxGiACIAIoAhQgAWo2AhQgASADaiEECyAEC1kBAX8gACAAKAJIIgFBAWsgAXI2AkggACgCACIBQQhxBEAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEACwsAIAAQJBogABAWCzEBAn8gAEGEMDYCACAAKAIEQQxrIgEgASgCCEEBayICNgIIIAJBAEgEQCABEBYLIAALmgEAIABBAToANQJAIAIgACgCBEcNACAAQQE6ADQCQCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0CIAAoAjBBAUYNAQwCCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRw0CIAJBAUYNAQwCCyAAIAAoAiRBAWo2AiQLIABBAToANgsLSwEBfwJAIAFFDQAgAUHkKxAVIgFFDQAgASgCCCAAKAIIQX9zcQ0AIAAoAgwg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QQEhDCAFQQFqIgVBCkcNAQwLCwsgBUEKTwRAQQEhDAwKCwNAIAQgBUECdGooAgANAUEBIQwgBUEBaiIFQQpHDQALDAkLQRwhCAwGCyAGIAU6ACdBASEHIBYhCyAJIQoLIAcgCCALayIJIAcgCUobIgEgEEH/////B3NKDQNBPSEIIA8gASAQaiIHIAcgD0gbIgUgF0sNBCAAQSAgBSAHIAoQGCAAIBQgEBAbIABBMCAFIAcgCkGAgARzEBggAEEwIAEgCUEAEBggACALIAkQGyAAQSAgBSAHIApBgMAAcxAYIAYoAjwhAQwBCwsLQQAhDAwDC0E9IQgLQbDKACAINgIAC0F/IQwLIAZBQGskACAMC30BA38CQAJAIAAiAUEDcUUNACABLQAARQRAQQAPCwNAIAFBAWoiAUEDcUUNASABLQAADQALDAELA0AgASICQQRqIQFBgIKECCACKAIAIgNrIANyQYCBgoR4cUGAgYKEeEYNAAsDQCACIgFBAWohAiABLQAADQALCyABIABrCzEAIAECfyACKAJMQQBIBEAgACABIAIQIQwBCyAAIAEgAhAhCyIARgRADwsgACABbhoLiwQBA38gAkGABE8EQCACBEAgACABIAL8CgAACyAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLIANBfHEhBAJAIANBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyACQQRJBEAgACECDAELIANBBGshBCAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoA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NgIAEDRBpMoAQZzKACgCADYCAEGcygBBoMoANgIAQajKAEERNgIAQazKAEEANgIAECdBrMoAQZzKACgCADYCAEGcygBBqMoANgIAQczLAEHUygA2AgBBpMsAQYCABDYCAEGgywBB8M8ENgIAQYTLAEEqNgIAQajLAEGAyQAoAgA2AgALC6BAFABBgAgLhh44FwAACAQAAE4xMGVtc2NyaXB0ZW4zdmFsRQAgezB4JTA4eCwgMHglMDh4fQBmcmVlX3Jlc3VsdF9tZW1vcnkACiAgICBjb21iaW5lZCBDUkNzOiBzdG9yZWQgPSAweCUwOHgsIGNvbXB1dGVkID0gMHglMDh4AC0rICAgMFgweAB1bnNpZ25lZCBzaG9ydAB1bnNpZ25lZCBpbnQAQloyUmVzdWx0AGZsb2F0AGRlY29tcHJlc3MAJXM6JWQ6ICVzAG91dHB1dFB0cgB2ZWN0b3IAZXJyb3IAdW5zaWduZWQgY2hhcgAvZW1zZGsvZW1zY3JpcHRlbi9zeXN0ZW0vbGliL2xpYmN4eGFiaS9zcmMvcHJpdmF0ZV90eXBlaW5mby5jcHAAc3RkOjpleGNlcHRpb24Ab3V0cHV0TGVuAGJvb2wAZXJyb3JNc2cAdW5zaWduZWQgbG9uZyBsb25nAHVuc2lnbmVkIGxvbmcAc3RkOjp3c3RyaW5nAGJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBkb3VibGUAcnQrcmxkAHZvaWQAY2F0Y2hpbmcgYSBjbGFzcyB3aXRob3V0IGFuIG9iamVjdD8AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AMS4wLjYsIDYtU2VwdC0yMDEwAFRoZSBkZWNvbXByZXNzZWQgZGF0YSBleGNlZWRzIHRoZSAxMDBNQiBzYWZldHkgbGltaXQuAEZhaWxlZCB0byBhbGxvY2F0ZSBtZW1vcnkgZm9yIHRoZSBvdXRwdXQgYnVmZmVyLgBBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIGR1cmluZyBkZWNvbXByZXNzaW9uLgBEYXRhIG1hZ2ljIGVycm9yOiBOb3QgYSB2YWxpZCBiemlwMiBmaWxlLgAobnVsbCkACiAgICBbJWQ6IGh1ZmYrbXRmIAAKKioqIEEgc3BlY2lhbCBub3RlIGFib3V0IGludGVybmFsIGVycm9yIG51bWJlciAxMDA3ICoqKgoKRXhwZXJpZW5jZSBzdWdnZXN0cyB0aGF0IGEgY29tbW9uIGNhdXNlIG9mIGkuZS4gMTAwNwppcyB1bnJlbGlhYmxlIG1lbW9yeSBvciBvdGhlciBoYXJkd2FyZS4gIFRoZSAxMDA3IGFzc2VydGlvbgpqdXN0IGhhcHBlbnMgdG8gY3Jvc3MtY2hlY2sgdGhlIHJlc3VsdHMgb2YgaHVnZSBudW1iZXJzIG9mCm1lbW9yeSByZWFkcy93cml0ZXMsIGFuZCBzbyBhY3RzICh1bmludGVuZGVkbHkpIGFzIGEgc3RyZXNzCnRlc3Qgb2YgeW91ciBtZW1vcnkgc3lzdGVtLgoKSSBzdWdnZXN0IHRoZSBmb2xsb3dpbmc6IHRyeSBjb21wcmVzc2luZyB0aGUgZmlsZSBhZ2FpbiwKcG9zc2libHkgbW9uaXRvcmluZyBwcm9ncmVzcyBpbiBkZXRhaWwgd2l0aCB0aGUgLXZ2IGZsYWcuCgoqIElmIHRoZSBlcnJvciBjYW5ub3QgYmUgcmVwcm9kdWNlZCwgYW5kL29yIGhhcHBlbnMgYXQgZGlmZmVyZW50CiAgcG9pbnRzIGluIGNvbXByZXNzaW9uLCB5b3UgbWF5IGhhdmUgYSBmbGFreSBtZW1vcnkgc3lzdGVtLgogIFRyeSBhIG1lbW9yeS10ZXN0IHByb2dyYW0uICBJIGhhdmUgdXNlZCBNZW10ZXN0ODYKICAod3d3Lm1lbXRlc3Q4Ni5jb20pLiAgQXQgdGhlIHRpbWUgb2Ygd3JpdGluZyBpdCBpcyBmcmVlIChHUExkKS4KICBNZW10ZXN0ODYgdGVzdHMgbWVtb3J5IG11Y2ggbW9yZSB0aG9yb3VnbHkgdGhhbiB5b3VyIEJJT1NzCiAgcG93ZXItb24gdGVzdCwgYW5kIG1heSBmaW5kIGZhaWx1cmVzIHRoYXQgdGhlIEJJT1MgZG9lc24ndC4KCiogSWYgdGhlIGVycm9yIGNhbiBiZSByZXBlYXRhYmx5IHJlcHJvZHVjZWQsIHRoaXMgaXMgYSBidWcgaW4KICBiemlwMiwgYW5kIEkgd291bGQgdmVyeSBtdWNoIGxpa2UgdG8gaGVhciBhYm91dCBpdC4gIFBsZWFzZQogIGxldCBtZSBrbm93LCBhbmQsIGlkZWFsbHksIHNhdmUgYSBjb3B5IG9mIHRoZSBmaWxlIGNhdXNpbmcgdGhlCiAgcHJvYmxlbSAtLSB3aXRob3V0IHdoaWNoIEkgd2lsbCBiZSB1bmFibGUgdG8gaW52ZXN0aWdhdGUgaXQuCgoACgpiemlwMi9saWJiemlwMjogaW50ZXJuYWwgZXJyb3IgbnVtYmVyICVkLgpUaGlzIGlzIGEgYnVnIGluIGJ6aXAyL2xpYmJ6aXAyLCAlcy4KUGxlYXNlIHJlcG9ydCBpdCB0byBtZSBhdDoganNld2FyZEBiemlwLm9yZy4gIElmIHRoaXMgaGFwcGVuZWQKd2hlbiB5b3Ugd2VyZSB1c2luZyBzb21lIHByb2dyYW0gd2hpY2ggdXNlcyBsaWJiemlwMiBhcyBhCmNvbXBvbmVudCwgeW91IHNob3VsZCBhbHNvIHJlcG9ydCB0aGlzIGJ1ZyB0byB0aGUgYXV0aG9yKHMpCm9mIHRoYXQgcHJvZ3JhbS4gIFBsZWFzZSBtYWtlIGFuIGVmZm9ydCB0byByZXBvcnQgdGhpcyBidWc7CnRpbWVseSBhbmQgYWNjdXJhdGUgYnVnIHJlcG9ydHMgZXZlbnR1YWxseSBsZWFkIHRvIGhpZ2hlcgpxdWFsaXR5IHNvZnR3YXJlLiAgVGhhbmtzLiAgSnVsaWFuIFNld2FyZCwgMTAgRGVjZW1iZXIgMjAwNy4KCgAAOBcAAEAPAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAAOBcAAIgPAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRHNOU18xMWNoYXJfdHJhaXRzSURzRUVOU185YWxsb2NhdG9ySURzRUVFRQAAADgXAADUDwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURpTlNfMTFjaGFyX3RyYWl0c0lEaUVFTlNfOWFsbG9jYXRvcklEaUVFRUUAAAA4FwAAIBAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQAAOBcAAEgQAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAADgXAABwEAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAAA4FwAAmBAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQAAOBcAAMAQAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUAADgXAADoEAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAAA4FwAAEBEAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQAAOBcAADgRAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAADgXAABgEQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAAA4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");
  }
  function getBinarySync(file) {
    if (ArrayBuffer.isView(file)) {
      return file;
    }
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  async function getWasmBinary(binaryFile) {
    return getBinarySync(binaryFile);
  }
  async function instantiateArrayBuffer(binaryFile, imports) {
    try {
      var binary = await getWasmBinary(binaryFile);
      var instance = await WebAssembly.instantiate(binary, imports);
      return instance;
    } catch (reason) {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    }
  }
  async function instantiateAsync(binary, binaryFile, imports) {
    return instantiateArrayBuffer(binaryFile, imports);
  }
  function getWasmImports() {
    return { a: wasmImports };
  }
  async function createWasm() {
    function receiveInstance(instance, module) {
      wasmExports = instance.exports;
      wasmMemory = wasmExports["t"];
      updateMemoryViews();
      wasmTable = wasmExports["y"];
      assignWasmExports(wasmExports);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result2) {
      return receiveInstance(result2["instance"]);
    }
    var info = getWasmImports();
    if (Module["instantiateWasm"]) {
      return new Promise((resolve, reject) => {
        Module["instantiateWasm"](info, (mod, inst) => {
          resolve(receiveInstance(mod, inst));
        });
      });
    }
    wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
  }
  class ExitStatus {
    name = "ExitStatus";
    constructor(status) {
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.push(cb);
  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.push(cb);
  var base64Decode = (b64) => {
    var b1, b2, i2 = 0, j = 0, bLength = b64.length;
    var output = new Uint8Array((bLength * 3 >> 2) - (b64[bLength - 2] == "=") - (b64[bLength - 1] == "="));
    for (; i2 < bLength; i2 += 4, j += 3) {
      b1 = base64ReverseLookup[b64.charCodeAt(i2 + 1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i2 + 2)];
      output[j] = base64ReverseLookup[b64.charCodeAt(i2)] << 2 | b1 >> 4;
      output[j + 1] = b1 << 4 | b2 >> 2;
      output[j + 2] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i2 + 3)];
    }
    return output;
  };
  var noExitRuntime = true;
  class ExceptionInfo {
    constructor(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
    }
    set_type(type) {
      HEAPU32[this.ptr + 4 >> 2] = type;
    }
    get_type() {
      return HEAPU32[this.ptr + 4 >> 2];
    }
    set_destructor(destructor) {
      HEAPU32[this.ptr + 8 >> 2] = destructor;
    }
    get_destructor() {
      return HEAPU32[this.ptr + 8 >> 2];
    }
    set_caught(caught) {
      caught = caught ? 1 : 0;
      HEAP8[this.ptr + 12] = caught;
    }
    get_caught() {
      return HEAP8[this.ptr + 12] != 0;
    }
    set_rethrown(rethrown) {
      rethrown = rethrown ? 1 : 0;
      HEAP8[this.ptr + 13] = rethrown;
    }
    get_rethrown() {
      return HEAP8[this.ptr + 13] != 0;
    }
    init(type, destructor) {
      this.set_adjusted_ptr(0);
      this.set_type(type);
      this.set_destructor(destructor);
    }
    set_adjusted_ptr(adjustedPtr) {
      HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
    }
    get_adjusted_ptr() {
      return HEAPU32[this.ptr + 16 >> 2];
    }
  }
  var exceptionLast = 0;
  var uncaughtExceptionCount = 0;
  var ___cxa_throw = (ptr, type, destructor) => {
    var info = new ExceptionInfo(ptr);
    info.init(type, destructor);
    exceptionLast = ptr;
    uncaughtExceptionCount++;
    throw exceptionLast;
  };
  var __abort_js = () => abort("");
  var AsciiToString = (ptr) => {
    var str = "";
    while (1) {
      var ch = HEAPU8[ptr++];
      if (!ch) return str;
      str += String.fromCharCode(ch);
    }
  };
  var awaitingDependencies = {};
  var registeredTypes = {};
  var typeDependencies = {};
  var BindingError = class BindingError extends Error {
    constructor(message) {
      super(message);
      this.name = "BindingError";
    }
  };
  var throwBindingError = (message) => {
    throw new BindingError(message);
  };
  function sharedRegisterType(rawType, registeredInstance, options = {}) {
    var name = registeredInstance.name;
    if (!rawType) {
      throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
    }
    if (registeredTypes.hasOwnProperty(rawType)) {
      if (options.ignoreDuplicateRegistrations) {
        return;
      } else {
        throwBindingError(`Cannot register type '${name}' twice`);
      }
    }
    registeredTypes[rawType] = registeredInstance;
    delete typeDependencies[rawType];
    if (awaitingDependencies.hasOwnProperty(rawType)) {
      var callbacks = awaitingDependencies[rawType];
      delete awaitingDependencies[rawType];
      callbacks.forEach((cb) => cb());
    }
  }
  function registerType(rawType, registeredInstance, options = {}) {
    return sharedRegisterType(rawType, registeredInstance, options);
  }
  var integerReadValueFromPointer = (name, width, signed) => {
    switch (width) {
      case 1:
        return signed ? (pointer) => HEAP8[pointer] : (pointer) => HEAPU8[pointer];
      case 2:
        return signed ? (pointer) => HEAP16[pointer >> 1] : (pointer) => HEAPU16[pointer >> 1];
      case 4:
        return signed ? (pointer) => HEAP32[pointer >> 2] : (pointer) => HEAPU32[pointer >> 2];
      case 8:
        return signed ? (pointer) => HEAP64[pointer >> 3] : (pointer) => HEAPU64[pointer >> 3];
      default:
        throw new TypeError(`invalid integer width (${width}): ${name}`);
    }
  };
  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {
    name = AsciiToString(name);
    const isUnsignedType = minRange === 0n;
    let fromWireType = (value) => value;
    if (isUnsignedType) {
      const bitSize = size * 8;
      fromWireType = (value) => BigInt.asUintN(bitSize, value);
      maxRange = fromWireType(maxRange);
    }
    registerType(primitiveType, { name, fromWireType, toWireType: (destructors, value) => {
      if (typeof value == "number") {
        value = BigInt(value);
      }
      return value;
    }, readValueFromPointer: integerReadValueFromPointer(name, size, !isUnsignedType), destructorFunction: null });
  };
  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {
    name = AsciiToString(name);
    registerType(rawType, { name, fromWireType: function(wt) {
      return !!wt;
    }, toWireType: function(destructors, o) {
      return o ? trueValue : falseValue;
    }, readValueFromPointer: function(pointer) {
      return this.fromWireType(HEAPU8[pointer]);
    }, destructorFunction: null });
  };
  var shallowCopyInternalPointer = (o) => ({ count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType });
  var throwInstanceAlreadyDeleted = (obj) => {
    function getInstanceTypeName(handle) {
      return handle.$$.ptrType.registeredClass.name;
    }
    throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
  };
  var finalizationRegistry = false;
  var detachFinalizer = (handle) => {
  };
  var runDestructor = ($$) => {
    if ($$.smartPtr) {
      $$.smartPtrType.rawDestructor($$.smartPtr);
    } else {
      $$.ptrType.registeredClass.rawDestructor($$.ptr);
    }
  };
  var releaseClassHandle = ($$) => {
    $$.count.value -= 1;
    var toDelete = 0 === $$.count.value;
    if (toDelete) {
      runDestructor($$);
    }
  };
  var attachFinalizer = (handle) => {
    if ("undefined" === typeof FinalizationRegistry) {
      attachFinalizer = (handle2) => handle2;
      return handle;
    }
    finalizationRegistry = new FinalizationRegistry((info) => {
      releaseClassHandle(info.$$);
    });
    attachFinalizer = (handle2) => {
      var $$ = handle2.$$;
      var hasSmartPtr = !!$$.smartPtr;
      if (hasSmartPtr) {
        var info = { $$ };
        finalizationRegistry.register(handle2, info, handle2);
      }
      return handle2;
    };
    detachFinalizer = (handle2) => finalizationRegistry.unregister(handle2);
    return attachFinalizer(handle);
  };
  var deletionQueue = [];
  var flushPendingDeletes = () => {
    while (deletionQueue.length) {
      var obj = deletionQueue.pop();
      obj.$$.deleteScheduled = false;
      obj["delete"]();
    }
  };
  var delayFunction;
  var init_ClassHandle = () => {
    let proto = ClassHandle.prototype;
    Object.assign(proto, { isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
        return false;
      }
      if (!(other instanceof ClassHandle)) {
        return false;
      }
      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      other.$$ = other.$$;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;
      while (leftClass.baseClass) {
        left = leftClass.upcast(left);
        leftClass = leftClass.baseClass;
      }
      while (rightClass.baseClass) {
        right = rightClass.upcast(right);
        rightClass = rightClass.baseClass;
      }
      return leftClass === rightClass && left === right;
    }, clone() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.preservePointerOnDelete) {
        this.$$.count.value += 1;
        return this;
      } else {
        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
        clone.$$.count.value += 1;
        clone.$$.deleteScheduled = false;
        return clone;
      }
    }, delete() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError("Object already scheduled for deletion");
      }
      detachFinalizer(this);
      releaseClassHandle(this.$$);
      if (!this.$$.preservePointerOnDelete) {
        this.$$.smartPtr = void 0;
        this.$$.ptr = void 0;
      }
    }, isDeleted() {
      return !this.$$.ptr;
    }, deleteLater() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError("Object already scheduled for deletion");
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this;
    } });
    const symbolDispose = Symbol.dispose;
    if (symbolDispose) {
      proto[symbolDispose] = proto["delete"];
    }
  };
  function ClassHandle() {
  }
  var createNamedFunction = (name, func) => Object.defineProperty(func, "name", { value: name });
  var registeredPointers = {};
  var ensureOverloadTable = (proto, methodName, humanName) => {
    if (void 0 === proto[methodName].overloadTable) {
      var prevFunc = proto[methodName];
      proto[methodName] = function(...args) {
        if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
          throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
        }
        return proto[methodName].overloadTable[args.length].apply(this, args);
      };
      proto[methodName].overloadTable = [];
      proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
    }
  };
  var exposePublicSymbol = (name, value, numArguments) => {
    if (Module.hasOwnProperty(name)) {
      if (void 0 === numArguments || void 0 !== Module[name].overloadTable && void 0 !== Module[name].overloadTable[numArguments]) {
        throwBindingError(`Cannot register public name '${name}' twice`);
      }
      ensureOverloadTable(Module, name, name);
      if (Module[name].overloadTable.hasOwnProperty(numArguments)) {
        throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
      }
      Module[name].overloadTable[numArguments] = value;
    } else {
      Module[name] = value;
      Module[name].argCount = numArguments;
    }
  };
  var char_0 = 48;
  var char_9 = 57;
  var makeLegalFunctionName = (name) => {
    name = name.replace(/[^a-zA-Z0-9_]/g, "$");
    var f = name.charCodeAt(0);
    if (f >= char_0 && f <= char_9) {
      return `_${name}`;
    }
    return name;
  };
  function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
    this.name = name;
    this.constructor = constructor;
    this.instancePrototype = instancePrototype;
    this.rawDestructor = rawDestructor;
    this.baseClass = baseClass;
    this.getActualType = getActualType;
    this.upcast = upcast;
    this.downcast = downcast;
    this.pureVirtualFunctions = [];
  }
  var upcastPointer = (ptr, ptrClass, desiredClass) => {
    while (ptrClass !== desiredClass) {
      if (!ptrClass.upcast) {
        throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
      }
      ptr = ptrClass.upcast(ptr);
      ptrClass = ptrClass.baseClass;
    }
    return ptr;
  };
  var embindRepr = (v) => {
    if (v === null) {
      return "null";
    }
    var t = typeof v;
    if (t === "object" || t === "array" || t === "function") {
      return v.toString();
    } else {
      return "" + v;
    }
  };
  function constNoSmartPtrRawPointerToWireType(destructors, handle) {
    if (handle === null) {
      if (this.isReference) {
        throwBindingError(`null is not a valid ${this.name}`);
      }
      return 0;
    }
    if (!handle.$$) {
      throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
    }
    if (!handle.$$.ptr) {
      throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    return ptr;
  }
  function genericPointerToWireType(destructors, handle) {
    var ptr;
    if (handle === null) {
      if (this.isReference) {
        throwBindingError(`null is not a valid ${this.name}`);
      }
      if (this.isSmartPointer) {
        ptr = this.rawConstructor();
        if (destructors !== null) {
          destructors.push(this.rawDestructor, ptr);
        }
        return ptr;
      } else {
        return 0;
      }
    }
    if (!handle || !handle.$$) {
      throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
    }
    if (!handle.$$.ptr) {
      throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
    }
    if (!this.isConst && handle.$$.ptrType.isConst) {
      throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    if (this.isSmartPointer) {
      if (void 0 === handle.$$.smartPtr) {
        throwBindingError("Passing raw pointer to smart pointer is illegal");
      }
      switch (this.sharingPolicy) {
        case 0:
          if (handle.$$.smartPtrType === this) {
            ptr = handle.$$.smartPtr;
          } else {
            throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
          }
          break;
        case 1:
          ptr = handle.$$.smartPtr;
          break;
        case 2:
          if (handle.$$.smartPtrType === this) {
            ptr = handle.$$.smartPtr;
          } else {
            var clonedHandle = handle["clone"]();
            ptr = this.rawShare(ptr, Emval.toHandle(() => clonedHandle["delete"]()));
            if (destructors !== null) {
              destructors.push(this.rawDestructor, ptr);
            }
          }
          break;
        default:
          throwBindingError("Unsupporting sharing policy");
      }
    }
    return ptr;
  }
  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
    if (handle === null) {
      if (this.isReference) {
        throwBindingError(`null is not a valid ${this.name}`);
      }
      return 0;
    }
    if (!handle.$$) {
      throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
    }
    if (!handle.$$.ptr) {
      throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
    }
    if (handle.$$.ptrType.isConst) {
      throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    return ptr;
  }
  function readPointer(pointer) {
    return this.fromWireType(HEAPU32[pointer >> 2]);
  }
  var downcastPointer = (ptr, ptrClass, desiredClass) => {
    if (ptrClass === desiredClass) {
      return ptr;
    }
    if (void 0 === desiredClass.baseClass) {
      return null;
    }
    var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
    if (rv === null) {
      return null;
    }
    return desiredClass.downcast(rv);
  };
  var registeredInstances = {};
  var getBasestPointer = (class_, ptr) => {
    if (ptr === void 0) {
      throwBindingError("ptr should not be undefined");
    }
    while (class_.baseClass) {
      ptr = class_.upcast(ptr);
      class_ = class_.baseClass;
    }
    return ptr;
  };
  var getInheritedInstance = (class_, ptr) => {
    ptr = getBasestPointer(class_, ptr);
    return registeredInstances[ptr];
  };
  var InternalError = class InternalError extends Error {
    constructor(message) {
      super(message);
      this.name = "InternalError";
    }
  };
  var throwInternalError = (message) => {
    throw new InternalError(message);
  };
  var makeClassHandle = (prototype, record) => {
    if (!record.ptrType || !record.ptr) {
      throwInternalError("makeClassHandle requires ptr and ptrType");
    }
    var hasSmartPtrType = !!record.smartPtrType;
    var hasSmartPtr = !!record.smartPtr;
    if (hasSmartPtrType !== hasSmartPtr) {
      throwInternalError("Both smartPtrType and smartPtr must be specified");
    }
    record.count = { value: 1 };
    return attachFinalizer(Object.create(prototype, { $$: { value: record, writable: true } }));
  };
  function RegisteredPointer_fromWireType(ptr) {
    var rawPointer = this.getPointee(ptr);
    if (!rawPointer) {
      this.destructor(ptr);
      return null;
    }
    var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
    if (void 0 !== registeredInstance) {
      if (0 === registeredInstance.$$.count.value) {
        registeredInstance.$$.ptr = rawPointer;
        registeredInstance.$$.smartPtr = ptr;
        return registeredInstance["clone"]();
      } else {
        var rv = registeredInstance["clone"]();
        this.destructor(ptr);
        return rv;
      }
    }
    function makeDefaultHandle() {
      if (this.isSmartPointer) {
        return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
      } else {
        return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
      }
    }
    var actualType = this.registeredClass.getActualType(rawPointer);
    var registeredPointerRecord = registeredPointers[actualType];
    if (!registeredPointerRecord) {
      return makeDefaultHandle.call(this);
    }
    var toType;
    if (this.isConst) {
      toType = registeredPointerRecord.constPointerType;
    } else {
      toType = registeredPointerRecord.pointerType;
    }
    var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
    if (dp === null) {
      return makeDefaultHandle.call(this);
    }
    if (this.isSmartPointer) {
      return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
    } else {
      return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
    }
  }
  var init_RegisteredPointer = () => {
    Object.assign(RegisteredPointer.prototype, { getPointee(ptr) {
      if (this.rawGetPointee) {
        ptr = this.rawGetPointee(ptr);
      }
      return ptr;
    }, destructor(ptr) {
      this.rawDestructor?.(ptr);
    }, readValueFromPointer: readPointer, fromWireType: RegisteredPointer_fromWireType });
  };
  function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
    this.name = name;
    this.registeredClass = registeredClass;
    this.isReference = isReference;
    this.isConst = isConst;
    this.isSmartPointer = isSmartPointer;
    this.pointeeType = pointeeType;
    this.sharingPolicy = sharingPolicy;
    this.rawGetPointee = rawGetPointee;
    this.rawConstructor = rawConstructor;
    this.rawShare = rawShare;
    this.rawDestructor = rawDestructor;
    if (!isSmartPointer && registeredClass.baseClass === void 0) {
      if (isConst) {
        this.toWireType = constNoSmartPtrRawPointerToWireType;
        this.destructorFunction = null;
      } else {
        this.toWireType = nonConstNoSmartPtrRawPointerToWireType;
        this.destructorFunction = null;
      }
    } else {
      this.toWireType = genericPointerToWireType;
    }
  }
  var replacePublicSymbol = (name, value, numArguments) => {
    if (!Module.hasOwnProperty(name)) {
      throwInternalError("Replacing nonexistent public symbol");
    }
    if (void 0 !== Module[name].overloadTable && void 0 !== numArguments) {
      Module[name].overloadTable[numArguments] = value;
    } else {
      Module[name] = value;
      Module[name].argCount = numArguments;
    }
  };
  var wasmTableMirror = [];
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
    var func = wasmTableMirror[funcPtr];
    if (!func) {
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
    }
    return func;
  };
  var embind__requireFunction = (signature, rawFunction, isAsync = false) => {
    signature = AsciiToString(signature);
    function makeDynCaller() {
      var rtn = getWasmTableEntry(rawFunction);
      return rtn;
    }
    var fp = makeDynCaller();
    if (typeof fp != "function") {
      throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
    }
    return fp;
  };
  class UnboundTypeError extends Error {
  }
  var getTypeName = (type) => {
    var ptr = ___getTypeName(type);
    var rv = AsciiToString(ptr);
    _free(ptr);
    return rv;
  };
  var throwUnboundTypeError = (message, types) => {
    var unboundTypes = [];
    var seen = {};
    function visit(type) {
      if (seen[type]) {
        return;
      }
      if (registeredTypes[type]) {
        return;
      }
      if (typeDependencies[type]) {
        typeDependencies[type].forEach(visit);
        return;
      }
      unboundTypes.push(type);
      seen[type] = true;
    }
    types.forEach(visit);
    throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
  };
  var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
    myTypes.forEach((type) => typeDependencies[type] = dependentTypes);
    function onComplete(typeConverters2) {
      var myTypeConverters = getTypeConverters(typeConverters2);
      if (myTypeConverters.length !== myTypes.length) {
        throwInternalError("Mismatched type converter count");
      }
      for (var i2 = 0; i2 < myTypes.length; ++i2) {
        registerType(myTypes[i2], myTypeConverters[i2]);
      }
    }
    var typeConverters = new Array(dependentTypes.length);
    var unregisteredTypes = [];
    var registered = 0;
    dependentTypes.forEach((dt, i2) => {
      if (registeredTypes.hasOwnProperty(dt)) {
        typeConverters[i2] = registeredTypes[dt];
      } else {
        unregisteredTypes.push(dt);
        if (!awaitingDependencies.hasOwnProperty(dt)) {
          awaitingDependencies[dt] = [];
        }
        awaitingDependencies[dt].push(() => {
          typeConverters[i2] = registeredTypes[dt];
          ++registered;
          if (registered === unregisteredTypes.length) {
            onComplete(typeConverters);
          }
        });
      }
    });
    if (0 === unregisteredTypes.length) {
      onComplete(typeConverters);
    }
  };
  var __embind_register_class = (rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) => {
    name = AsciiToString(name);
    getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
    upcast &&= embind__requireFunction(upcastSignature, upcast);
    downcast &&= embind__requireFunction(downcastSignature, downcast);
    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
    var legalFunctionName = makeLegalFunctionName(name);
    exposePublicSymbol(legalFunctionName, function() {
      throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);
    });
    whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], (base) => {
      base = base[0];
      var baseClass;
      var basePrototype;
      if (baseClassRawType) {
        baseClass = base.registeredClass;
        basePrototype = baseClass.instancePrototype;
      } else {
        basePrototype = ClassHandle.prototype;
      }
      var constructor = createNamedFunction(name, function(...args) {
        if (Object.getPrototypeOf(this) !== instancePrototype) {
          throw new BindingError(`Use 'new' to construct ${name}`);
        }
        if (void 0 === registeredClass.constructor_body) {
          throw new BindingError(`${name} has no accessible constructor`);
        }
        var body = registeredClass.constructor_body[args.length];
        if (void 0 === body) {
          throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
        }
        return body.apply(this, args);
      });
      var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
      constructor.prototype = instancePrototype;
      var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
      if (registeredClass.baseClass) {
        registeredClass.baseClass.__derivedClasses ??= [];
        registeredClass.baseClass.__derivedClasses.push(registeredClass);
      }
      var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
      var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
      var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
      registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
      replacePublicSymbol(legalFunctionName, constructor);
      return [referenceConverter, pointerConverter, constPointerConverter];
    });
  };
  var runDestructors = (destructors) => {
    while (destructors.length) {
      var ptr = destructors.pop();
      var del = destructors.pop();
      del(ptr);
    }
  };
  var validateThis = (this_, classType, humanName) => {
    if (!(this_ instanceof Object)) {
      throwBindingError(`${humanName} with invalid "this": ${this_}`);
    }
    if (!(this_ instanceof classType.registeredClass.constructor)) {
      throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
    }
    if (!this_.$$.ptr) {
      throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
    }
    return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
  };
  var __embind_register_class_property = (classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) => {
    fieldName = AsciiToString(fieldName);
    getter = embind__requireFunction(getterSignature, getter);
    whenDependentTypesAreResolved([], [classType], (classType2) => {
      classType2 = classType2[0];
      var humanName = `${classType2.name}.${fieldName}`;
      var desc = { get() {
        throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
      }, enumerable: true, configurable: true };
      if (setter) {
        desc.set = () => throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
      } else {
        desc.set = (v) => throwBindingError(humanName + " is a read-only property");
      }
      Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
      whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], (types) => {
        var getterReturnType2 = types[0];
        var desc2 = { get() {
          var ptr = validateThis(this, classType2, humanName + " getter");
          return getterReturnType2.fromWireType(getter(getterContext, ptr));
        }, enumerable: true };
        if (setter) {
          setter = embind__requireFunction(setterSignature, setter);
          var setterArgumentType2 = types[1];
          desc2.set = function(v) {
            var ptr = validateThis(this, classType2, humanName + " setter");
            var destructors = [];
            setter(setterContext, ptr, setterArgumentType2.toWireType(destructors, v));
            runDestructors(destructors);
          };
        }
        Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
        return [];
      });
      return [];
    });
  };
  var emval_freelist = [];
  var emval_handles = [0, 1, , 1, null, 1, true, 1, false, 1];
  var __emval_decref = (handle) => {
    if (handle > 9 && 0 === --emval_handles[handle + 1]) {
      emval_handles[handle] = void 0;
      emval_freelist.push(handle);
    }
  };
  var Emval = { toValue: (handle) => {
    if (!handle) {
      throwBindingError(`Cannot use deleted val. handle = ${handle}`);
    }
    return emval_handles[handle];
  }, toHandle: (value) => {
    switch (value) {
      case void 0:
        return 2;
      case null:
        return 4;
      case true:
        return 6;
      case false:
        return 8;
      default: {
        const handle = emval_freelist.pop() || emval_handles.length;
        emval_handles[handle] = value;
        emval_handles[handle + 1] = 1;
        return handle;
      }
    }
  } };
  var EmValType = { name: "emscripten::val", fromWireType: (handle) => {
    var rv = Emval.toValue(handle);
    __emval_decref(handle);
    return rv;
  }, toWireType: (destructors, value) => Emval.toHandle(value), readValueFromPointer: readPointer, destructorFunction: null };
  var __embind_register_emval = (rawType) => registerType(rawType, EmValType);
  var floatReadValueFromPointer = (name, width) => {
    switch (width) {
      case 4:
        return function(pointer) {
          return this.fromWireType(HEAPF32[pointer >> 2]);
        };
      case 8:
        return function(pointer) {
          return this.fromWireType(HEAPF64[pointer >> 3]);
        };
      default:
        throw new TypeError(`invalid float width (${width}): ${name}`);
    }
  };
  var __embind_register_float = (rawType, name, size) => {
    name = AsciiToString(name);
    registerType(rawType, { name, fromWireType: (value) => value, toWireType: (destructors, value) => value, readValueFromPointer: floatReadValueFromPointer(name, size), destructorFunction: null });
  };
  function usesDestructorStack(argTypes) {
    for (var i2 = 1; i2 < argTypes.length; ++i2) {
      if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {
        return true;
      }
    }
    return false;
  }
  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
    var needsDestructorStack = usesDestructorStack(argTypes);
    var argCount = argTypes.length - 2;
    var argsList = [];
    var argsListWired = ["fn"];
    if (isClassMethodFunc) {
      argsListWired.push("thisWired");
    }
    for (var i2 = 0; i2 < argCount; ++i2) {
      argsList.push(`arg${i2}`);
      argsListWired.push(`arg${i2}Wired`);
    }
    argsList = argsList.join(",");
    argsListWired = argsListWired.join(",");
    var invokerFnBody = `return function (${argsList}) {
`;
    if (needsDestructorStack) {
      invokerFnBody += "var destructors = [];\n";
    }
    var dtorStack = needsDestructorStack ? "destructors" : "null";
    var args1 = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "fromRetWire", "toClassParamWire"];
    if (isClassMethodFunc) {
      invokerFnBody += `var thisWired = toClassParamWire(${dtorStack}, this);
`;
    }
    for (var i2 = 0; i2 < argCount; ++i2) {
      var argName = `toArg${i2}Wire`;
      invokerFnBody += `var arg${i2}Wired = ${argName}(${dtorStack}, arg${i2});
`;
      args1.push(argName);
    }
    invokerFnBody += (returns || isAsync ? "var rv = " : "") + `invoker(${argsListWired});
`;
    if (needsDestructorStack) {
      invokerFnBody += "runDestructors(destructors);\n";
    } else {
      for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
        var paramName = i2 === 1 ? "thisWired" : "arg" + (i2 - 2) + "Wired";
        if (argTypes[i2].destructorFunction !== null) {
          invokerFnBody += `${paramName}_dtor(${paramName});
`;
          args1.push(`${paramName}_dtor`);
        }
      }
    }
    if (returns) {
      invokerFnBody += "var ret = fromRetWire(rv);\nreturn ret;\n";
    } else {
    }
    invokerFnBody += "}\n";
    return new Function(args1, invokerFnBody);
  }
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
    var argCount = argTypes.length;
    if (argCount < 2) {
      throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
    }
    var isClassMethodFunc = argTypes[1] !== null && classType !== null;
    var needsDestructorStack = usesDestructorStack(argTypes);
    var returns = !argTypes[0].isVoid;
    var retType = argTypes[0];
    var instType = argTypes[1];
    var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, retType.fromWireType.bind(retType), instType?.toWireType.bind(instType)];
    for (var i2 = 2; i2 < argCount; ++i2) {
      var argType = argTypes[i2];
      closureArgs.push(argType.toWireType.bind(argType));
    }
    if (!needsDestructorStack) {
      for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
        if (argTypes[i2].destructorFunction !== null) {
          closureArgs.push(argTypes[i2].destructorFunction);
        }
      }
    }
    let invokerFactory = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);
    var invokerFn = invokerFactory(...closureArgs);
    return createNamedFunction(humanName, invokerFn);
  }
  var heap32VectorToArray = (count, firstElement) => {
    var array = [];
    for (var i2 = 0; i2 < count; i2++) {
      array.push(HEAPU32[firstElement + i2 * 4 >> 2]);
    }
    return array;
  };
  var getFunctionName = (signature) => {
    signature = signature.trim();
    const argsIndex = signature.indexOf("(");
    if (argsIndex === -1) return signature;
    return signature.slice(0, argsIndex);
  };
  var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) => {
    var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
    name = AsciiToString(name);
    name = getFunctionName(name);
    rawInvoker = embind__requireFunction(signature, rawInvoker, isAsync);
    exposePublicSymbol(name, function() {
      throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
    }, argCount - 1);
    whenDependentTypesAreResolved([], argTypes, (argTypes2) => {
      var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
      replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
      return [];
    });
  };
  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {
    name = AsciiToString(name);
    const isUnsignedType = minRange === 0;
    let fromWireType = (value) => value;
    if (isUnsignedType) {
      var bitshift = 32 - 8 * size;
      fromWireType = (value) => value << bitshift >>> bitshift;
      maxRange = fromWireType(maxRange);
    }
    registerType(primitiveType, { name, fromWireType, toWireType: (destructors, value) => value, readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0), destructorFunction: null });
  };
  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {
    var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array];
    var TA = typeMapping[dataTypeIndex];
    function decodeMemoryView(handle) {
      var size = HEAPU32[handle >> 2];
      var data = HEAPU32[handle + 4 >> 2];
      return new TA(HEAP8.buffer, data, size);
    }
    name = AsciiToString(name);
    registerType(rawType, { name, fromWireType: decodeMemoryView, readValueFromPointer: decodeMemoryView }, { ignoreDuplicateRegistrations: true });
  };
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0)) return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i2 = 0; i2 < str.length; ++i2) {
      var u = str.codePointAt(i2);
      if (u <= 127) {
        if (outIdx >= endIdx) break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx) break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx) break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx) break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
        i2++;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i2 = 0; i2 < str.length; ++i2) {
      var c = str.charCodeAt(i2);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i2;
      } else {
        len += 3;
      }
    }
    return len;
  };
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
  var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {
    var maxIdx = idx + maxBytesToRead;
    if (ignoreNul) return maxIdx;
    while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;
    return idx;
  };
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {
    var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : "";
  var __embind_register_std_string = (rawType, name) => {
    name = AsciiToString(name);
    var stdStringIsUTF8 = true;
    registerType(rawType, { name, fromWireType(value) {
      var length = HEAPU32[value >> 2];
      var payload = value + 4;
      var str;
      if (stdStringIsUTF8) {
        str = UTF8ToString(payload, length, true);
      } else {
        str = "";
        for (var i2 = 0; i2 < length; ++i2) {
          str += String.fromCharCode(HEAPU8[payload + i2]);
        }
      }
      _free(value);
      return str;
    }, toWireType(destructors, value) {
      if (value instanceof ArrayBuffer) {
        value = new Uint8Array(value);
      }
      var length;
      var valueIsOfTypeString = typeof value == "string";
      if (!(valueIsOfTypeString || ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1)) {
        throwBindingError("Cannot pass non-string to std::string");
      }
      if (stdStringIsUTF8 && valueIsOfTypeString) {
        length = lengthBytesUTF8(value);
      } else {
        length = value.length;
      }
      var base = _malloc(4 + length + 1);
      var ptr = base + 4;
      HEAPU32[base >> 2] = length;
      if (valueIsOfTypeString) {
        if (stdStringIsUTF8) {
          stringToUTF8(value, ptr, length + 1);
        } else {
          for (var i2 = 0; i2 < length; ++i2) {
            var charCode = value.charCodeAt(i2);
            if (charCode > 255) {
              _free(base);
              throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
            }
            HEAPU8[ptr + i2] = charCode;
          }
        }
      } else {
        HEAPU8.set(value, ptr);
      }
      if (destructors !== null) {
        destructors.push(_free, base);
      }
      return base;
    }, readValueFromPointer: readPointer, destructorFunction(ptr) {
      _free(ptr);
    } });
  };
  var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
  var UTF16ToString = (ptr, maxBytesToRead, ignoreNul) => {
    var idx = ptr >> 1;
    var endIdx = findStringEnd(HEAPU16, idx, maxBytesToRead / 2, ignoreNul);
    if (endIdx - idx > 16 && UTF16Decoder) return UTF16Decoder.decode(HEAPU16.subarray(idx, endIdx));
    var str = "";
    for (var i2 = idx; i2 < endIdx; ++i2) {
      var codeUnit = HEAPU16[i2];
      str += String.fromCharCode(codeUnit);
    }
    return str;
  };
  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
    maxBytesToWrite ??= 2147483647;
    if (maxBytesToWrite < 2) return 0;
    maxBytesToWrite -= 2;
    var startPtr = outPtr;
    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
    for (var i2 = 0; i2 < numCharsToWrite; ++i2) {
      var codeUnit = str.charCodeAt(i2);
      HEAP16[outPtr >> 1] = codeUnit;
      outPtr += 2;
    }
    HEAP16[outPtr >> 1] = 0;
    return outPtr - startPtr;
  };
  var lengthBytesUTF16 = (str) => str.length * 2;
  var UTF32ToString = (ptr, maxBytesToRead, ignoreNul) => {
    var str = "";
    var startIdx = ptr >> 2;
    for (var i2 = 0; !(i2 >= maxBytesToRead / 4); i2++) {
      var utf32 = HEAPU32[startIdx + i2];
      if (!utf32 && !ignoreNul) break;
      str += String.fromCodePoint(utf32);
    }
    return str;
  };
  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
    maxBytesToWrite ??= 2147483647;
    if (maxBytesToWrite < 4) return 0;
    var startPtr = outPtr;
    var endPtr = startPtr + maxBytesToWrite - 4;
    for (var i2 = 0; i2 < str.length; ++i2) {
      var codePoint = str.codePointAt(i2);
      if (codePoint > 65535) {
        i2++;
      }
      HEAP32[outPtr >> 2] = codePoint;
      outPtr += 4;
      if (outPtr + 4 > endPtr) break;
    }
    HEAP32[outPtr >> 2] = 0;
    return outPtr - startPtr;
  };
  var lengthBytesUTF32 = (str) => {
    var len = 0;
    for (var i2 = 0; i2 < str.length; ++i2) {
      var codePoint = str.codePointAt(i2);
      if (codePoint > 65535) {
        i2++;
      }
      len += 4;
    }
    return len;
  };
  var __embind_register_std_wstring = (rawType, charSize, name) => {
    name = AsciiToString(name);
    var decodeString, encodeString, lengthBytesUTF;
    if (charSize === 2) {
      decodeString = UTF16ToString;
      encodeString = stringToUTF16;
      lengthBytesUTF = lengthBytesUTF16;
    } else {
      decodeString = UTF32ToString;
      encodeString = stringToUTF32;
      lengthBytesUTF = lengthBytesUTF32;
    }
    registerType(rawType, { name, fromWireType: (value) => {
      var length = HEAPU32[value >> 2];
      var str = decodeString(value + 4, length * charSize, true);
      _free(value);
      return str;
    }, toWireType: (destructors, value) => {
      if (!(typeof value == "string")) {
        throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
      }
      var length = lengthBytesUTF(value);
      var ptr = _malloc(4 + length + charSize);
      HEAPU32[ptr >> 2] = length / charSize;
      encodeString(value, ptr + 4, length + charSize);
      if (destructors !== null) {
        destructors.push(_free, ptr);
      }
      return ptr;
    }, readValueFromPointer: readPointer, destructorFunction(ptr) {
      _free(ptr);
    } });
  };
  var __embind_register_void = (rawType, name) => {
    name = AsciiToString(name);
    registerType(rawType, { isVoid: true, name, fromWireType: () => void 0, toWireType: (destructors, o) => void 0 });
  };
  var getHeapMax = () => 2147483648;
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var growMemory = (size) => {
    var oldHeapSize = wasmMemory.buffer.byteLength;
    var pages = (size - oldHeapSize + 65535) / 65536 | 0;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    _proc_exit(status);
  };
  var _exit = exitJS;
  var _fd_close = (fd) => 52;
  var INT53_MAX = 9007199254740992;
  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);
    return 70;
  }
  var printCharBuffers = [null, [], []];
  var printChar = (stream, curr) => {
    var buffer = printCharBuffers[stream];
    if (curr === 0 || curr === 10) {
      (stream === 1 ? out : err)(UTF8ArrayToString(buffer));
      buffer.length = 0;
    } else {
      buffer.push(curr);
    }
  };
  var _fd_write = (fd, iov, iovcnt, pnum) => {
    var num = 0;
    for (var i2 = 0; i2 < iovcnt; i2++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      for (var j = 0; j < len; j++) {
        printChar(fd, HEAPU8[ptr + j]);
      }
      num += len;
    }
    HEAPU32[pnum >> 2] = num;
    return 0;
  };
  for (var base64ReverseLookup = new Uint8Array(123), i = 25; i >= 0; --i) {
    base64ReverseLookup[48 + i] = 52 + i;
    base64ReverseLookup[65 + i] = i;
    base64ReverseLookup[97 + i] = 26 + i;
  }
  base64ReverseLookup[43] = 62;
  base64ReverseLookup[47] = 63;
  init_ClassHandle();
  init_RegisteredPointer();
  {
    if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];
    if (Module["print"]) out = Module["print"];
    if (Module["printErr"]) err = Module["printErr"];
    if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
    if (Module["arguments"]) arguments_ = Module["arguments"];
    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
  }
  var ___getTypeName, _malloc, _free;
  function assignWasmExports(wasmExports2) {
    ___getTypeName = wasmExports2["v"];
    Module["_malloc"] = _malloc = wasmExports2["w"];
    Module["_free"] = _free = wasmExports2["x"];
  }
  var wasmImports = { l: ___cxa_throw, m: __abort_js, f: __embind_register_bigint, j: __embind_register_bool, s: __embind_register_class, c: __embind_register_class_property, r: __embind_register_emval, e: __embind_register_float, g: __embind_register_function, b: __embind_register_integer, a: __embind_register_memory_view, i: __embind_register_std_string, d: __embind_register_std_wstring, k: __embind_register_void, n: _emscripten_resize_heap, q: _exit, p: _fd_close, o: _fd_seek, h: _fd_write };
  var wasmExports = await createWasm();
  function run() {
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    preRun();
    if (runDependencies > 0) {
      dependenciesFulfilled = run;
      return;
    }
    function doRun() {
      Module["calledRun"] = true;
      if (ABORT) return;
      initRuntime();
      readyPromiseResolve?.(Module);
      Module["onRuntimeInitialized"]?.();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(() => {
        setTimeout(() => Module["setStatus"](""), 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  function preInit() {
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].shift()();
      }
    }
  }
  preInit();
  run();
  if (runtimeInitialized) {
    moduleRtn = Module;
  } else {
    moduleRtn = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
  }
  ;
  return moduleRtn;
}
var bzip2_wasm_es_default = Bzip2Module;

// wrapper.js
var bzip2Module = await bzip2_wasm_es_default();
function decompress(compressedBytes) {
  if (!(compressedBytes instanceof Uint8Array)) {
    throw new TypeError("Bzip2.decompress: Input must be a Uint8Array.");
  }
  if (compressedBytes.length === 0) {
    return new Uint8Array(0);
  }
  let inputPtr = 0;
  let result = null;
  try {
    inputPtr = bzip2Module._malloc(compressedBytes.length);
    if (inputPtr === 0) {
      throw new Error("Bzip2: Failed to allocate memory for input buffer.");
    }
    bzip2Module.HEAPU8.set(compressedBytes, inputPtr);
    result = bzip2Module.decompress(inputPtr, compressedBytes.length);
    if (result.error !== 0) {
      throw new Error(`Bzip2 decompression failed: ${result.errorMsg} (code: ${result.error})`);
    }
    const outputBytes = bzip2Module.HEAPU8.slice(result.outputPtr, result.outputPtr + result.outputLen);
    return outputBytes;
  } finally {
    if (inputPtr) {
      bzip2Module._free(inputPtr);
    }
    if (result) {
      if (result.outputPtr) {
        bzip2Module.free_result_memory(result.outputPtr);
      }
      result.delete();
    }
  }
}
var Bzip2 = { decompress };
var wrapper_default = Bzip2;
export {
  wrapper_default as default
};
